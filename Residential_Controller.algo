DEFINE elevator

  SET id TO: AUTOINCREMENT id,
  SET state TO on_service,
  SET InternalList to empty list
  SET max_weight TO 1000
  SET current_weight TO 0
  SET current_floor TO current_floor
  SET idle_time TO 0
  SET elevator_status TO idle
  SET doors_open TO false
  SET door_closing_path_clear TO true
  SET overload to false
  SET elevator_is_moving TO false
  SET elevator_direction TO NONE
  SET floors_gap_elev TO 0

  SEQUENCE createInternalList using total_elevators
     [...]
  ENDSEQUENCE

  SEQUENCE get_current_weight USING weight_sensor
    SET current_weight TO READ weight_sensor
  ENDSEQUENCE

  SEQUENCE handle_idle_time
    IF idle_time IS GREATER THAN 5 minutes THEN
    SET current_floor TO 1
    SET elevator_status TO idle
  ENDSEQUENCE

  SEQUENCE check_doors_open
    CALL open_doors
    IF doors_open EQUALS TO true
      SET doors_open TO true
    ENDIF
  ENDSEQUENCE

  SEQUENCE check_door_path USING doors_sensor
    IF nothing IS BETWEEN doors_sensor THEN
      SET door_closing_path_clear TO true
    ELSE
      SET door_closing_path_clear TO false
    ENDIF
  ENDSEQUENCE

  SEQUENCE check_overload USING current_weight AND max_weight
    IF current_weight IS LESS than max_weight THEN
      SET overload TO false
    ELSE
      SET overload TO true
      DISPLAY 'There is an overload'
      CALL overload_sound
      SET doors_open TO true
      Wait 5 seconds
      Check again
    ENDIF
  ENDSEQUENCE

  SEQUENCE get_elev_movement
    CALL elevator_direction
    IF elevator_direction IS EQUAL TO UP OR DOWN THEN
      SET elevator_is_moving TO true
    ELSE
      SET elevator_is_moving TO false
    ENDIF
  ENDSEQUENCE

  SEQUENCE get_elevator_direction USING InternalList ARRAY, current_floor AND elevator_is_moving
    IF current_item IN InternalList ARRAY IS GREATER THAN current_floor THEN
      SET elevator_direction TO UP
      SET elevator_is_moving TO true
    ELSE current_item IN InternalList ARRAY IS LESS THAN current_floor THEN
      SET elevator_direction TO DOWN
      SET elevator_is_moving TO true
    ELSE
      SET elevator_direction TO NONE
    ENDIF
  ENDSEQUENCE

  SEQUENCE start_moving USING doors_open, requested_floor AND overload
    IF doors_open EQUALS TO false AND InternalList ARRAY IS GREATER THAN 0 AND overload EQUALS TO  false THEN
      CALL get_elevator_direction
      SET elevator_is_moving TO true
    ENDIF
  ENDSEQUENCE

  SEQUENCE open_doors USING elevator_is_moving, current_floor, InternalList ARRAY AND open_doors_button
    IF elevator_is_moving IS NOT EQUAL TO true AND current_floor EQUALS TO    requested_floor OR open_doors_button IS PRESSED THEN
      SET doors_open TO true
    ELSE
      Wait 5 seconds
      Check again
    ENDIF
  ENDSEQUENCE

  SEQUENCE close_doors USING close_door_button, door_closing_path_clear AND overload
    IF close_door_button IS PRESSED AND door_closing_path_clear EQUALS TO true AND  overload EQUALS TO false THEN
      SET doors_open TO false
      close doors
    ELSE close_door_button IS NOT PRESSED AND door_closing_path_clear EQUALS TO true AND overload EQUALS TO false THEN
      Wait 5 seconds
      Check again
    ENDIF
  ENDSEQUENCE

  SEQUENCE floors_gap_elev USING queue_requested_floors ARRAY AND current_floor
    FOR EACH item IN queue_requested_floors ARRAY
      READ current_item
      SET floors_gap_elev TO current_item IN queue_requested_floors ARRAY MINUS elevator's current_floor
    ENDFOR
  ENDSEQUENCE
    

ENDDEFINE

-----------Creating elevators array--------------
SEQUENCE elevators USING total_elevators
  [...]
ENDSEQUENCE


--------Defining and creating columns-----------
DEFINE Columns
 SET number_cols TO number_cols
 SET number_floors TO number_floors
 SET total_elevators TO total_elevators
 SET col_status TO col_status
ENDDEFINE

SET column1 TO INSTANTIATE Columns WITH 1, 10, 2 AND on_service
----------------------------------
------Create new elevator call construct-----------

DEFINE ElevatorCall USING direction AND call_from_floor
  Direction: requested_direction,
  CallFromFloor: call_from_floor
ENDDEFINE 
------------------------------------------------------

-------------BUTTONS REQUEST ELEVATRO UP & DOWN----------

FOR EACH column IN total_columns

   SEQUENCE elevator_requested USING call_elevator_button_down OR   call_elevator_button_up
     IF call_elevator_button_up IS PRESSED THEN
       READ call_from_floor
       SET new ElevatorCall WITH call_from_floor AND Direction UP
       ADD ElevatorCall TO queue_requested_floors ARRAY
       SORT queue_requested_floors ARRAY (descending)
     ELSE call_elevator_button_down IS PRESSED THEN
       READ call_from_floor
       SET new ElevatorCall WITH call_from_floor AND Direction DOWN
       ADD ElevatorCall TO queue_requested_floors ARRAY
       SORT queue_requested_floors ARRAY (ascending)
   ENDSEQUENCE

ENDFOR
----------------------------------------------------

SEQUENCE sort_internalList USING elevator_direction
  IF elevator_direction EQUALS TO UP THEN
    SORT InternalList ARRAY (descending)
  ELSE
    SORT InternalList ARRAY (ascending)
  ENDIF
ENDSEQUENCE

-------------BUTTONS REQUESTED FLOOR----------------

SEQUENCE floor_requested USING requested_floor_buttons

   FOR EACH column IN total_columns
    FOR EACH elevator IN column
     READ requested_floor_button
     ADD TO InternalList ARRAY
     CALL sort_internalList
     ENDIF
    ENDFOR
   ENDFOR

ENDSEQUENCE
-------------------------------------------------------

-------------SEND ELEVATOR LOGIC-----------------------

FOR EACH column IN total_columns
  FOR EACH elevator IN column
   SEQUENCE deciding_elevator

    FOR EACH item IN queue_requested_floors ARRAY
      CASE asnwering_call_in_queue OF
        CASE 1:
          floors_gap_elev[i] IS LESS THAN floors_gap_elev[i+1] AND elevator[i]_direction EQUALS TO ElevatorCall.Direction INSIDE queue_requested_floors ARRAY THEN
           SEND elevator1
           ADD current_item IN queue_requested_floors ARRAY TO InternalList ARRAY
           CALL sort_internalList
           DELETE current_item FROM queue_requested_floors ARRAY
        CASE 2: 
          floors_gap_elev2 IS LESS THAN floors_gap_elev1 AND elevator2_direction EQUALS  TO ElevatorCall.Direction INSIDE queue_requested_floors ARRAY THEN
           SEND elevator2
           ADD current_item IN queue_requested_floors ARRAY TO InternalList ARRAY
           CALL sort_internalList
           DELETE current_item FROM queue_requested_floors ARRAY
        CASE 3:
          elevator_status1 IS idle OR floors_gap_elev1 IS LESS THAN floors_gap_elev2 THEN
            SEND elevator1
            ADD current_item IN queue_requested_floors ARRAY TO InternalList ARRAY
            CALL sort_internalList
            DELETE current_item FROM queue_requested_floors ARRAY
        CASE 4:
          elevator_status2 IS idle OR floors_gap_elev2 IS LESS THAN floors_gap_elev1 THEN
            SEND elevator2
            ADD current_item IN queue_requested_floors ARRAY TO InternalList ARRAY
            CALL sort_internalList
            DELETE current_item FROM queue_requested_floors ARRAY
      ENDCASE 
    ENDFOR
   ENDSEQUENCE
  ENDFOR
ENDFOR

-------------------------------------------------------
-----------Check elevator direction & requested direction------

SEQUENCE elevator_direction_check_queue USING elevator_direction, deciding_elevator AND current_floor
 IF elevator_direction IS UP AND 1 of 4 deciding_elevator CASES IS true BUT requested_floor < current_floor THEN
   Ignore request
 ELSE elevator_direction IS going_down AND 1 of 4 deciding_elevator CASES IS true BUT requested_floor > current_floor THEN
   Ignore request
 ENDIF
ENDSEQUENCE
-------------------------------------------------------

-------Answering and deleting calls--------------------

   WHILE InternalList ARRAY OR queue_requested_floors ARRAY IS GREATER THAN 0 AND    elevator_status IS on_service

     SEQUENCE completing_floor_requests USING InternalList ARRAY AND queue_requested_floors ARRAY
      FOR EACH item IN queue_requested_floors ARRAY
       IF current_item IN InternalList ARRAY EQUALS TO current_floor THEN
         CALL stop
         CALL open_doors
         DELETE current item from InternalList ARRAY 
         READ next_item IN InternalList ARRAY
         CALL deciding_elevator
       ELSEIF current_item IN queue_requested_floors ARRAY EQUALS TO current_floor THEN
         CALL stop
         CALL open_doors
         READ next_item IN InternalList ARRAY
         CALL deciding_elevator
     ENDSEQUENCE
   ENDWHILE

ENDWHILE
----------------------------------------------------------------

WHILE column IS on_service
  RUN ALL elevator SEQUENCES
  RUN completing_floor_requests
  RUN deciding_elevator
  RUN floor_requested
  RUN sort_internalList
ENDWHILE













   


















