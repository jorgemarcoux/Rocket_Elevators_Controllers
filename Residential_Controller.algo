------Create new elevator call construct-----------

DEFINE ElevatorCall USING direction AND call_from_floor
  Direction: requested_direction,
  CallFromFloor: call_from_floor
ENDDEFINE 
------------------------------------------------------



















-------------BUTTONS REQUEST ELEVATRO UP & DOWN----------

FOR EACH column IN total_columns

   SEQUENCE elevator_requested USING call_elevator_button_down OR   call_elevator_button_up
     IF call_elevator_button_up IS PRESSED THEN
       READ call_from_floor
       SET new ElevatorCall WITH call_from_floor AND Direction UP
       ADD ElevatorCall TO queue_requested_floors ARRAY
       SORT queue_requested_floors ARRAY (descending)
     ELSE call_elevator_button_down IS PRESSED THEN
       READ call_from_floor
       SET new ElevatorCall WITH call_from_floor AND Direction DOWN
       ADD ElevatorCall TO queue_requested_floors ARRAY
       SORT queue_requested_floors ARRAY (ascending)
   ENDSEQUENCE

ENDFOR
----------------------------------------------------

SEQUENCE sort_internalList USING elevator_direction
  IF elevator_direction EQUALS TO UP THEN
    SORT InternalList ARRAY (descending)
  ELSE
    SORT InternalList ARRAY (ascending)
  ENDIF
ENDSEQUENCE

-------------BUTTONS REQUESTED FLOOR----------------

SEQUENCE floor_requested USING requested_floor_buttons

   FOR EACH column IN total_columns
    FOR EACH elevator IN column
     READ requested_floor_button
     ADD TO InternalList ARRAY
     CALL sort_internalList
     ENDIF
    ENDFOR
   ENDFOR

ENDSEQUENCE
-------------------------------------------------------

-------------SEND ELEVATOR LOGIC-----------------------

FOR EACH column IN total_columns
  FOR EACH elevator IN column
   SEQUENCE deciding_elevator

    FOR EACH item IN queue_requested_floors ARRAY
      CASE asnwering_call_in_queue OF
        CASE 1:
          floors_gap_elev[i] IS LESS THAN floors_gap_elev[i+1] AND elevator[i]_direction EQUALS TO ElevatorCall.Direction INSIDE queue_requested_floors ARRAY THEN
           SEND elevator1
           ADD current_item IN queue_requested_floors ARRAY TO InternalList ARRAY
           CALL sort_internalList
           DELETE current_item FROM queue_requested_floors ARRAY
        CASE 2: 
          floors_gap_elev2 IS LESS THAN floors_gap_elev1 AND elevator2_direction EQUALS  TO ElevatorCall.Direction INSIDE queue_requested_floors ARRAY THEN
           SEND elevator2
           ADD current_item IN queue_requested_floors ARRAY TO InternalList ARRAY
           CALL sort_internalList
           DELETE current_item FROM queue_requested_floors ARRAY
        CASE 3:
          elevator_status1 IS idle OR floors_gap_elev1 IS LESS THAN floors_gap_elev2 THEN
            SEND elevator1
            ADD current_item IN queue_requested_floors ARRAY TO InternalList ARRAY
            CALL sort_internalList
            DELETE current_item FROM queue_requested_floors ARRAY
        CASE 4:
          elevator_status2 IS idle OR floors_gap_elev2 IS LESS THAN floors_gap_elev1 THEN
            SEND elevator2
            ADD current_item IN queue_requested_floors ARRAY TO InternalList ARRAY
            CALL sort_internalList
            DELETE current_item FROM queue_requested_floors ARRAY
      ENDCASE 
    ENDFOR
   ENDSEQUENCE
  ENDFOR
ENDFOR

-------------------------------------------------------
-------Answering and deleting calls--------------------

   WHILE InternalList ARRAY OR queue_requested_floors ARRAY IS GREATER THAN 0 AND    elevator_status IS on_service

     SEQUENCE completing_floor_requests USING InternalList ARRAY AND queue_requested_floors ARRAY
      FOR EACH item IN queue_requested_floors ARRAY
       IF current_item IN InternalList ARRAY EQUALS TO current_floor THEN
         CALL stop
         CALL open_doors
         DELETE current item from InternalList ARRAY 
         READ next_item IN InternalList ARRAY
         CALL deciding_elevator
       ELSEIF current_item IN queue_requested_floors ARRAY EQUALS TO current_floor THEN
         CALL stop
         CALL open_doors
         READ next_item IN InternalList ARRAY
         CALL deciding_elevator
     ENDSEQUENCE
   ENDWHILE

ENDWHILE
----------------------------------------------------------------

WHILE column IS on_service
  RUN ALL elevator SEQUENCES
  RUN completing_floor_requests
  RUN deciding_elevator
  RUN floor_requested
  RUN sort_internalList
ENDWHILE









//Sending elevator logic//
SEQUENCE sending_elevator USING queue_requested_floors ARRAY, InternalList ARRAY elevator_status, current_floor, elevator_is_moving, elevator1 OR elevator2 going_up OR going_down  
  IF elevator1 is elevator_is_moving, elevator2 status IS idle AND elevator2 current_floor IS LESS THAN CallFromFloor divided by 5 THEN
    SET sending_elevator TO elevator2

ENDSEQUENCE


SEQUENCE next_request_to_answer USING queue_requested_floors ARRAY, InternalList ARRAY, best_elevator AND current_floor
  FOR EACH item IN queue_requested_floors ARRAY AND IN InternalList ARRAY
   CASE best_elevator OF
    elevator1_up OR 1: 
     IF going_up AND next_item IN queue_requested_floors ARRAY MINUS current_floor IS LESS THAN next_item IN InternalList ARRAY MINUS current_floor THEN
       answer current_item IN queue_requested_floors ARRAY
       ADD current item from queue_requested_floors ARRAY TO InternalList ARRAY
       DELETE current item from queue_requested_floors ARRAY
     ELSEIF going_up AND next_item IN InternalList ARRAY MINUS current_floor MINUS THAN   next_item IN queue_requested_floors ARRAY MINUS current_floor THEN
       answer current_item IN InternalList ARRAY
     ENDIF
   












TO DO:
1.Check if other elevator already answered to next element in array
7. Add emergency button
11. Send 1 elevator to 1st Ã©tage et l'autre a total etages / 2 + 1
12. SET popular_floors array to track most used floors. Set idle elevators to those floors.





